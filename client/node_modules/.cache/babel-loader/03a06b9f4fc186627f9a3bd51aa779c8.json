{"ast":null,"code":"import { __assign } from 'tslib';\nimport * as React from 'react';\nimport { useContext } from 'react';\nimport { featureDefinitions } from './definitions.js';\nimport { invariant } from 'hey-listen';\nimport { LazyContext } from '../../context/LazyContext.js';\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\n\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n  var features = [];\n  var lazyContext = useContext(LazyContext);\n  if (!visualElement) return null;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && lazyContext.strict) {\n    invariant(false, \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\");\n  }\n\n  for (var i = 0; i < numFeatures; i++) {\n    var name_1 = featureNames[i];\n    var _a = featureDefinitions[name_1],\n        isEnabled = _a.isEnabled,\n        Component = _a.Component;\n    /**\n     * It might be possible in the future to use this moment to\n     * dynamically request functionality. In initial tests this\n     * was producing a lot of duplication amongst bundles.\n     */\n\n    if (isEnabled(props) && Component) {\n      features.push(React.createElement(Component, __assign({\n        key: name_1\n      }, props, {\n        visualElement: visualElement\n      })));\n    }\n  }\n\n  return features;\n}\n\nexport { useFeatures };","map":null,"metadata":{},"sourceType":"module"}